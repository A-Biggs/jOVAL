<html>
  <head>
    <title>jOVAL&trade;</title>
  </head>
  <body>
    <h1>The jOVAL&trade; Software Development Kit</h1>
    <p>jOVAL is an implementation of <a href="http://oval.mitre.org">OVAL</a> written in the Java programming language.  It is freely available for use under the <a href="http://www.joval.org/agpl_v3.txt">Affero GPL</a> license, and dual licensing is available for ISVs who require a commercial license.  Source code for jOVAL and all of its dependencies is hosted at Github, at <a href="https://www.github.com/joval">https://www.github.com/joval</a>.</p>

    <h2>jovaldi</h2>
    <p>jovaldi is a command-line OVAL definition interpreter that is implemented as part of the jOVAL library. It is intended to function as a drop-in replacement for MITRE's public-domain reference implementation, <a href="http://oval.mitre.org/language/interpreter.html">ovaldi</a>.  The primary advantage of jovaldi over ovaldi is that jovaldi features a remote-scanning plug-in, and therefore, it need not be installed on the hosts that it scans.  For more information, please see the <a href="http://www.joval.org">jOVAL home page</a></p>

    <h2>The jOVAL API</h2>
    <p>The jOVAL API consists of an OVAL data model, interfaces and internal implementation classes.  The data model is a JAXB-generated model based on the OVAL language schema specifications from MITRE.  Classes in the data model are all located in the <code>oval.*</code> package namespace.  The remaining classes are organized into the following packages:</p>
    <table cellpadding=10 cellspacing=10 width=1000>
      <tr>
        <td valign="top"><code>org.joval.util</code></td>
        <td>The primary class of interest in this package is the <code>JOVALSystem</code>, which can be considered the "main" class of the SDK.  The <code>JOVALSystem</code> is used to instantiate an engine, and to configure behaviors of the engine and certain plugin components.</td>
      </tr>
      <tr>
        <td valign="top"><code>org.joval.plugin</code></td>
        <td>The primary class of interest in this package is the <code>RemotePlugin</code>, which can be used to scan Windows, Mac OSX, Solaris, Linux and Cisco IOS devices over the network.</td>
      </tr>
      <tr>
        <td valign="top"><code>org.joval.intf.identity</code></td>
        <td>Interfaces in this package pertain to the management of machine access credentials.  The <code>RemotePlugin</code> uses a statically-defined <code>ICredentialStore</code> to look up host credentials.</td>
      </tr>
      <tr>
        <td valign="top"><code>org.joval.intf.oval</code></td>
        <td>Interfaces in this package pertain to OVAL constructs and the OVAL processing engine.</td>
      </tr>
      <tr>
        <td valign="top"><code>org.joval.intf.plugin</code></td>
        <td>Interfaces pertaining to jOVAL plugins and adapters.  The plugin is associated with a target machine, and provides adapters that understand how to probe the machine for items matching an object specification, identified in a request context.</td>
      </tr>
      <tr>
        <td valign="top"><code>org.joval.intf.util</code></td>
        <td>Interfaces pertaining to the producer/observer pattern used for engine notifications.
      </tr>
      <tr>
        <td valign="top"><code>org.joval.intf.system</code></td>
        <td>Interfaces pertaining to the execution of activities on machines.  The <code>ICredentialStore</code> interface takes an <code>IBaseSession</code> to determine the appropriate set of credentials to return.</td>
      </tr>
    </table>
    <p>The full public API javadoc documentation can be found <a href="api/index.html">here</a>.</p>

    <h2>Using jOVAL</h2>
    <p>The jOVAL library makes it easy to embed OVAL scanning capabilities inside a Java application, but since jovaldi seeks to fully duplicate the functions of ovaldi, it is not necessarily illustrative of how to use the classes.  Therefore, the following TrivialScanner code sample has been developed as a guide.  The basic steps are:</p>
    <ol>
      <li>Create an implementation of the <code>ICredentialStore</code> interface, and set it as the credential store for the <code>JOVALSystem</code>.  The sample app (and jovaldi) only scan a single machine, so they use the <code>SimpleCredentialStore</code> which contains credentials for only that one machine.  If your application will be scanning many devices, you'll need to implement a store that is able to provide credentials for all of them.</li>
      <li>(Optional) By default, <code>jOVALSystem</code> will provide a <code>SessionFactory</code> to plugins via the <code>getSessionFactory()</code> call.  The default factory can cache basic information about hosts (i.e., if they are Windows or SSH-enabled machines), so to prevent re-discovery and to get faster repeat-performance, it's a good idea to provide the factory with a data directory inside of which it can safely persist its cache file.</li>
      <li>Construct an instance of the <code>RemotePlugin</code> class, and set the target hostname or address using the <code>setTarget</code> method.</li>
      <li>Instantiate an engine using the <code>createEngine</code> method of the <code>JOVALSystem</code> class.</li>
      <li>Configure the engine by adding definitions (at minimum), and optionally add directives, a definition filter, etc.</li>
      <li>If you want to know what's happening inside the engine while it's running, register an <code>IObserver</code> to get notifications.</li>
      <li>Run the engine and get the <code>IResults</code>, which can be explored by accessing the data model via the <code>getOvalResults()</code> method.</li>
    </ol>
    <table border=1 cellpadding=15>
      <tr>
        <td bgcolor="#EEEEEE">
          <pre>
// Copyright (C) 2011 jOVAL.org.  All rights reserved.
// This software is licensed under the AGPL 3.0 license available at http://www.joval.org/agpl_v3.txt

import java.io.*;
import java.util.Properties;

import org.joval.identity.SimpleCredentialStore;
import org.joval.intf.oval.IEngine;
import org.joval.intf.oval.ISystemCharacteristics;
import org.joval.intf.oval.IResults;
import org.joval.intf.util.IObserver;
import org.joval.intf.util.IProducer;
import org.joval.oval.OvalException;
import org.joval.plugin.RemotePlugin;
import org.joval.util.JOVALSystem;

/**
 * A trivial implementation of an OVAL scanner using the jOVAL library.
 *
 * @author David A. Solin
 */
public class TrivialScanner {
    /**
     * The TrivialScanner accepts two command-line arguments.  The first is the path to an XML file containing OVAL
     * definitions, and the second is the path to a properties file containing configuration information for the
     * RemotePlugin class.
     */
    public static void main(String[] argv) {
        try {
            Properties props = new Properties();
            props.load(new FileInputStream(new File(argv[1])));

            RemotePlugin.setCredentialStore(new SimpleCredentialStore(props));
            RemotePlugin.setDataDirectory(new File("."));
            RemotePlugin plugin = new RemotePlugin(props.getProperty("hostname"));

            IEngine engine = JOVALSystem.createEngine(plugin);
            engine.setDefinitionsFile(new File(argv[0]));
            engine.getNotificationProducer().addObserver(new Observer(), IEngine.MESSAGE_MIN, IEngine.MESSAGE_MAX);
            engine.run();
            switch(engine.getResult()) {
              case OK:
                System.out.println("Writing resutls.xml");
                IResults results = engine.getResults();
                results.writeXML(new File("results.xml"));
                break;
              case ERR:
                throw engine.getError();
            }
            System.exit(0);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (OvalException e) {
            e.printStackTrace();
        }

        System.exit(1);
    }

    /**
     * An inner class that prints out information about Engine notifications.
     */
    static class Observer implements IObserver {
        public Observer() {}

        public void notify(IProducer source, int msg, Object arg) {
            switch(msg) {
              case IEngine.MESSAGE_OBJECT_PHASE_START:
                System.out.println("Scanning objects...");
                break;
              case IEngine.MESSAGE_OBJECT:
                System.out.println("  " + (String)arg);
                break;
              case IEngine.MESSAGE_OBJECT_PHASE_END:
                System.out.println("Done scanning");
                break;
              case IEngine.MESSAGE_SYSTEMCHARACTERISTICS:
                System.out.println("Saving system-characteristics.xml");
                ISystemCharacteristics sc = (ISystemCharacteristics)arg;
                sc.writeXML(new File("system-characteristics.xml"));
                break;
              case IEngine.MESSAGE_DEFINITION_PHASE_START:
                System.out.println("Evaluating definitions...");
                break;
              case IEngine.MESSAGE_DEFINITION:
                System.out.println("  " + (String)arg);
                break;
              case IEngine.MESSAGE_DEFINITION_PHASE_END:
                System.out.println("Done evaluating definitions");
                break;
              default:
                System.out.println("Unexpected message: " + msg);
                break;
            }
        }
    }
}
          </pre>
        </td>
      </tr>
    </table>
    <p>All original material Copyright &copy; 2011, jOVAL.org.  All rights reserved.
  </body>
</html>
