// Copyright (C) 2011 jOVAL.org.  All rights reserved.
// This software is licensed under the AGPL 3.0 license available at http://www.joval.org/agpl_v3.txt

package org.joval.scap.oval.adapter.windows;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.util.Hashtable;
import java.util.Collection;
import java.util.NoSuchElementException;
import java.util.HashSet;
import java.util.Vector;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.xml.bind.JAXBElement;

import oval.schemas.common.MessageLevelEnumeration;
import oval.schemas.common.MessageType;
import oval.schemas.common.OperationEnumeration;
import oval.schemas.common.SimpleDatatypeEnumeration;
import oval.schemas.definitions.core.EntityObjectStringType;
import oval.schemas.definitions.core.ObjectType;
import oval.schemas.definitions.windows.EntityObjectRegistryHiveType;
import oval.schemas.definitions.windows.RegistryBehaviors;
import oval.schemas.systemcharacteristics.core.EntityItemStringType;
import oval.schemas.systemcharacteristics.core.FlagEnumeration;
import oval.schemas.systemcharacteristics.core.ItemType;
import oval.schemas.systemcharacteristics.core.StatusEnumeration;
import oval.schemas.systemcharacteristics.windows.EntityItemRegistryHiveType;
import oval.schemas.systemcharacteristics.windows.EntityItemWindowsViewType;
import oval.schemas.results.core.ResultEnumeration;

import org.joval.intf.plugin.IAdapter;
import org.joval.intf.windows.registry.IKey;
import org.joval.intf.windows.registry.IRegistry;
import org.joval.intf.windows.system.IWindowsSession;
import org.joval.scap.oval.CollectException;
import org.joval.scap.oval.Factories;
import org.joval.util.JOVALMsg;

/**
 * Base class for IRegistry/IKey-based IAdapters. Subclasses need only implement getItemClass and getItems
 * methods. The base class handles searches and caching of search results.
 *
 * @author David A. Solin
 * @version %I% %G%
 */
public abstract class BaseRegkeyAdapter<T extends ItemType> implements IAdapter {
    protected IWindowsSession session;
    protected IRegistry reg32, reg;

    /**
     * Subclasses can call this method to initialize the session variable.
     */
    protected void init(IWindowsSession session) {
	this.session = session;
    }

    // Implement IAdapter

    public final Collection<T> getItems(ObjectType obj, IRequestContext rc) throws CollectException {
	init();
	Collection<T> items = new Vector<T>();
	ReflectedRegistryObject rObj = new ReflectedRegistryObject(obj);
	int winView = 0;
	if (rObj.isSetBehaviors()) {
	    if ("32_bit".equals(rObj.getBehaviors().getWindowsView())) {
		winView = 32;
	    }
	}
	if (winView == 0 && session.supports(IWindowsSession.View._64BIT)) {
	    winView = 64;
	}
	String hive = (String)rObj.getHive().getValue();
	for (String path : getPathList(rObj, hive, rc)) {
	    try {
		//
		// Fetch the IKey for the path
		//
		IKey key = null;
		if (path == null || path.length() == 0) {
		    key = (winView == 32 ? reg32 : reg).getHive(hive);
		} else {
		    key = (winView == 32 ? reg32 : reg).fetchKey(hive, path);
		}

		//
		// Create the base ItemType for the path
		//
		ReflectedRegkeyItem rItem = new ReflectedRegkeyItem();
		EntityItemRegistryHiveType hiveType = Factories.sc.windows.createEntityItemRegistryHiveType();
		hiveType.setValue(hive);
		rItem.setHive(hiveType);
		EntityItemStringType keyType = Factories.sc.core.createEntityItemStringType();
		keyType.setValue(path);
		rItem.setKey(keyType);
		switch(winView) {
		  case 32:
		    rItem.setWindowsView("32_bit");
		    break;
		  case 64:
		    rItem.setWindowsView("64_bit");
		    break;
		}

		//
		// Add items retrieved by the subclass
		//
		items.addAll(getItems(obj, rItem.it, key, rc));
	    } catch (NoSuchElementException e) {
		// No match.
	    } catch (CollectException e) {
		throw e;
	    } catch (Exception e) {
		MessageType msg = Factories.common.createMessageType();
		msg.setLevel(MessageLevelEnumeration.ERROR);
		msg.setValue(e.getMessage());
		rc.addMessage(msg);
		session.getLogger().debug(JOVALMsg.getMessage(JOVALMsg.ERROR_EXCEPTION), e);
	    }
	}
	return items;
    }

    // Protected

    /**
     * Return the Class of the ItemTypes generated by the subclass.
     */
    protected abstract Class getItemClass();

    /**
     * Return a list of items to associate with the given ObjectType, based on information gathered from the IKey.
     *
     * @arg it the base ItemType containing hive and key information already populated
     *
     * @throws NoSuchElementException if no matching item is found
     * @throws CollectException collection cannot take place and should be halted
     */
    protected abstract Collection<T> getItems(ObjectType obj, ItemType it, IKey key, IRequestContext rc) throws Exception;

    // Private

    /**
     * Idempotent initialization.
     */
    private void init() {
	if (reg32 == null) {
	    reg32 = session.getRegistry(IWindowsSession.View._32BIT);
	    if (session.supports(IWindowsSession.View._64BIT)) {
		reg = session.getRegistry(IWindowsSession.View._64BIT);
	    } else {
		reg = reg32;
	    }
	}
    }

    /**
     * Return the list of all registry key paths corresponding to the given RegistryObject.  Handles searches (from
     * pattern match operations), singletons (from equals operations), and searches based on RegistryBehaviors.
     */
    private Collection<String> getPathList(ReflectedRegistryObject rObj, String hive, IRequestContext rc)
		throws CollectException {

	boolean win32 = false;
	if (rObj.isSetBehaviors()) {
	    RegistryBehaviors behaviors = rObj.getBehaviors();
	    win32 = "32_bit".equals(behaviors.getWindowsView());
	}

	Collection<String> list = new HashSet<String>();
	boolean patternMatch = false;
	if (rObj.getKey() == null || rObj.getKey().getValue() == null) {
	    list.add(""); // special case
	} else {
	    String keypath = (String)rObj.getKey().getValue();
	    OperationEnumeration op = rObj.getKey().getOperation();
	    switch(op) {
	      case EQUALS:
		list.add(keypath);
		break;

	      case PATTERN_MATCH: {
		patternMatch = true;
		try {
		    for (IKey key : (win32 ? reg32 : reg).search(hive, keypath)) {
			if (!list.contains(key.getPath())) {
			    list.add(key.getPath());
			}
		    }
		} catch (NoSuchElementException e) {
		}
		break;
	      }

	      default:
		String msg = JOVALMsg.getMessage(JOVALMsg.ERROR_UNSUPPORTED_OPERATION, op);
		throw new CollectException(msg, FlagEnumeration.NOT_COLLECTED);
	    }
	}

	if (rObj.isSetBehaviors()) {
	    RegistryBehaviors behaviors = rObj.getBehaviors();
	    list = getPaths(hive, list, behaviors.getMaxDepth().intValue(), behaviors.getRecurseDirection(), win32);
	} else if (patternMatch) {
	    //
	    // Wildcard pattern matches are really supposed to be recursive searches, unfortunately
	    //
	    Collection<String> newList = new Vector<String>();
	    for (String value : list) {
		String keypath = (String)rObj.getKey().getValue();
		if (keypath.indexOf(".*") != -1 || keypath.indexOf(".+") != -1) {
		    Collection<String> l = new Vector<String>();
		    l.add(value);
		    newList.addAll(getPaths(hive, l, -1, "down", win32));
		}
	    }
	    for (String value : newList) {
		if (!list.contains(value)) {
		    list.add(value);
		}
	    }
	}

	return list;
    }

    /**
     * Recursively searchies for matches based on RegistryBehaviors.
     */
    private Collection<String> getPaths(String hive, Collection<String> list, int depth, String direction, boolean win32) {
	if ("none".equals(direction) || depth == 0) {
	    return list;
	} else {
	    Collection<String> results = new Vector<String>();
	    for (String path : list) {
		try {
		    IKey key = null;
		    if (path.length() > 0) {
			key = (win32 ? reg32 : reg).fetchKey(hive, path);
			results.add(path);
		    } else {
			key = (win32 ? reg32 : reg).fetchKey(hive);
		    }
		    if ("up".equals(direction)) {
			int ptr = 0;
			if (path.endsWith(IRegistry.DELIM_STR)) {
			    path = path.substring(0, path.lastIndexOf(IRegistry.DELIM_STR));
			}
			ptr = path.lastIndexOf(IRegistry.DELIM_STR);
			if (ptr != -1) {
			    Vector<String> v = new Vector<String>();
			    v.add(path.substring(0, ptr));
			    results.addAll(getPaths(hive, v, --depth, direction, win32));
			}
		    } else { // recurse down
			String[] children = key.listSubkeys();
			if (children != null) {
			    Vector<String> v = new Vector<String>();
			    for (int i=0; i < children.length; i++) {
				if (path.length() == 0) {
				    v.add(children[i]);
				} else {
				    v.add(path + IRegistry.DELIM_STR + children[i]);
				}
			    }
			    results.addAll(getPaths(hive, v, --depth, direction, win32));
			}
		    }
		} catch (NoSuchElementException e) {
		}
	    }
	    return results;
	}
    }

    /**
     * A reflection proxy for:
     *     oval.schemas.definitions.windows.RegistryObject
     *     oval.schemas.definitions.windows.RegkeyEffectiverights53Object
     *     oval.schemas.definitions.windows.RegkeyEffectiverightsObject
     */
    class ReflectedRegistryObject {
	ObjectType obj;
	String id = null;
	boolean keyNil = false;
	EntityObjectRegistryHiveType hive = null;
	EntityObjectStringType key = null;
	RegistryBehaviors behaviors = null;

	ReflectedRegistryObject(ObjectType obj) throws CollectException {
	    this.obj = obj;

	    try {
		Method getId = obj.getClass().getMethod("getId");
		Object o = getId.invoke(obj);
		if (o != null) {
		    id = (String)o;
		}
	    } catch (NoSuchMethodException e) {
	    } catch (IllegalAccessException e) {
	    } catch (IllegalArgumentException e) {
	    } catch (InvocationTargetException e) {
	    }

	    try {
		Method getHive = obj.getClass().getMethod("getHive");
		Object o = getHive.invoke(obj);
		if (o == null) {
		    throw new CollectException(JOVALMsg.getMessage(JOVALMsg.ERROR_WINREG_HIVE_NAME, id), FlagEnumeration.ERROR);
		} else {
		    hive = (EntityObjectRegistryHiveType)o;
		}
	    } catch (NoSuchMethodException e) {
	    } catch (IllegalAccessException e) {
	    } catch (IllegalArgumentException e) {
	    } catch (InvocationTargetException e) {
	    }

	    try {
		Method getKey = obj.getClass().getMethod("getKey");
		Object o = getKey.invoke(obj);
		if (o != null) {
		    if (o instanceof JAXBElement) {
			JAXBElement j = (JAXBElement)o;
			keyNil = j.isNil();
			o = j.getValue();
		    }
		    key = (EntityObjectStringType)o;
		}
	    } catch (NoSuchMethodException e) {
	    } catch (IllegalAccessException e) {
	    } catch (IllegalArgumentException e) {
	    } catch (InvocationTargetException e) {
	    }

	    try {
		Method getBehaviors = obj.getClass().getMethod("getBehaviors");
		Object o = getBehaviors.invoke(obj);
		if (o != null) {
		    behaviors = (RegistryBehaviors)o;
		}
	    } catch (NoSuchMethodException e) {
	    } catch (IllegalAccessException e) {
	    } catch (IllegalArgumentException e) {
	    } catch (InvocationTargetException e) {
	    }
	}

	public ObjectType getObject() {
	    return obj;
	}

	public String getId() {
	    return id;
	}

	public boolean isSetHive() {
	    return hive != null;
	}

	public EntityObjectRegistryHiveType getHive() {
	    return hive;
	}

	public boolean isKeyNil() {
	    return keyNil;
	}

	public boolean isSetKey() {
	    return key != null;
	}

	public EntityObjectStringType getKey() {
	    return key;
	}

	public boolean isSetBehaviors() {
	    return behaviors != null;
	}

	public RegistryBehaviors getBehaviors() {
	    return behaviors;
	}
    }

    /**
     * A reflection proxy for:
     *     oval.schemas.systemcharacteristics.windows.RegistryItem
     *     oval.schemas.systemcharacteristics.windows.RegkeyEffectiverightsItem
     */
    class ReflectedRegkeyItem {
	ItemType it;
	Method setHive, setKey, setStatus, setWindowsView, wrapKey=null;
	Object factory;

	ReflectedRegkeyItem() throws ClassNotFoundException, InstantiationException, NoSuchMethodException,
		IllegalAccessException, InvocationTargetException {

	    Class clazz = getItemClass();
	    String className = clazz.getName();
	    String packageName = clazz.getPackage().getName();
	    String unqualClassName = className.substring(packageName.length() + 1);
	    Class<?> factoryClass = Class.forName(packageName + ".ObjectFactory");
	    factory = factoryClass.newInstance();
	    Method createType = factoryClass.getMethod("create" + unqualClassName);
	    it = (ItemType)createType.invoke(factory);

	    Method[] methods = it.getClass().getMethods();
	    for (int i=0; i < methods.length; i++) {
		String name = methods[i].getName();
		if ("setHive".equals(name)) {
		    setHive = methods[i];
		} else if ("setKey".equals(name)) {
		    setKey = methods[i];
		    String keyClassName = setKey.getParameterTypes()[0].getName();
		    if (keyClassName.equals(JAXBElement.class.getName())) {
			String methodName = "create" + unqualClassName + "Key";
			wrapKey = factoryClass.getMethod(methodName, EntityItemStringType.class);
		    }
		} else if ("setStatus".equals(name)) {
		    setStatus = methods[i];
		} else if ("setWindowsView".equals(name)) {
		    setWindowsView = methods[i];
		}
	    }
	}

	void setWindowsView(String view) {
	    try {
		if (setWindowsView != null) {
		    Class[] types = setWindowsView.getParameterTypes();
		    if (types.length == 1) {
			Class type = types[0];
			Object instance = Class.forName(type.getName());
			@SuppressWarnings("unchecked")
			Method setValue = type.getMethod("setValue", Object.class);
			setValue.invoke(instance, view);
			setWindowsView.invoke(it, instance);
		    }
		}
	    } catch (NoSuchMethodException e) {
	    } catch (IllegalAccessException e) {
	    } catch (IllegalArgumentException e) {
	    } catch (InvocationTargetException e) {
	    } catch (ClassNotFoundException e) {
	    }
	}

	void setKey(EntityItemStringType key)
		throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	    if (setKey != null) {
		if (wrapKey == null) {
		    setKey.invoke(it, key);
		} else {
		    setKey.invoke(it, wrapKey.invoke(factory, key));
		}
	    }
	}

	void setHive(EntityItemRegistryHiveType hive)
		throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	    if (setHive != null) {
		setHive.invoke(it, hive);
	    }
	}

	void setStatus(StatusEnumeration status)
		throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
	    if (setStatus != null) {
		setStatus.invoke(it, status);
	    }
	}
    }
}
