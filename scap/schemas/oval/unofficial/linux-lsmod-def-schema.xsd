<?xml version="1.0" encoding="utf-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"
            xmlns:oval-def="http://oval.mitre.org/XMLSchema/oval-definitions-5"
            xmlns:linux-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"
            xmlns:sch="http://purl.oclc.org/dsdl/schematron"
            targetNamespace="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"
            elementFormDefault="qualified" version="5.11">
     <xsd:import namespace="http://oval.mitre.org/XMLSchema/oval-definitions-5"/>
     <xsd:import namespace="http://oval.mitre.org/XMLSchema/oval-common-5"/>
     <!-- =============================================================================== -->
     <!-- ================================  LSMOD TEST  ================================= -->
     <!-- =============================================================================== -->
     <xsd:element name="lsmod_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>
                    The "lsmod" Test is used to check information about the currently loaded kernel modules. It extends the standard TestType as defined in the oval-definitions-schema and 
                    one should refer to the TestType description for more information. The required object element references an lsmod_object and the optional state element specifies the 
                    data to check.
               </xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>lsmod_test</oval:test>
                         <oval:object>lsmod_object</oval:object>
                         <oval:state>lsmod_state</oval:state>
                         <oval:item>lsmod_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_lsmod_tst">
                         <sch:rule context="linux-def:lsmod_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:lsmod_object/@id"><sch:value-of select="../@id"/> - the object child element of a lsmod_test must reference a lsmod_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:lsmod_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:lsmod_state/@id"><sch:value-of select="../@id"/> - the state child element of a lsmod_test must reference a lsmod_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType"/>
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="lsmod_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>
                    The lsmod_object element is used by the lsmod_test to define the different information about the currently loaded kernel modules.
                    "lsmod" is a trivial program which nicely formats the contents of the /proc/modules, showing what kernel modules are currently loaded.
                    Because the command takes no arguments or parameters, implementations should parse the output of the "lsmod" command appropriately to 
                    discover the module_name being collected
               </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="module_name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>The name of the currently loaded module to collect.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="lsmod_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The "lsmod" state element allows for the evaluation of the status of currently loaded kernel modules.  Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="module_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The name of the currently loaded kernel module</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="module_size" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>Denotes the size of the kernel module (not memory used)</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="use_count" type="oval-def:EntityStateIntType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>Denotes the module's use count</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="used_by" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>
                                             "Used by" denotes each kernel module's list of referring modules. The "Used by" list is sometimes incomplete.  If the module controls its own unloading via a can_unload routine then the use count displayed by lsmod is always -1, irrespective of the real use count.
                                        </xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ==============================  MODPROBE TEST  =============================== -->
     <!-- =============================================================================== -->
     <xsd:element name="modprobe_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>
                    The modprobe test is used to check information for a given kernel module. It extends the standard TestType as defined in the oval-definitions-schema 
                    and one should refer to the TestType description for more information. The required object element references a modprobe_object and the optional state 
                    element specifies the data to check.
               </xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>modprobe_test</oval:test>
                         <oval:object>modprobe_object</oval:object>
                         <oval:state>modprobe_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">modprobe_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_modprobe_test">
                         <sch:rule context="linux-def:modprobe_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:modprobe_object/@id"><sch:value-of select="../@id"/> - the object child element of an modprobe_test must reference an modprobe_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:modprobe_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:modprobe_state/@id"><sch:value-of select="../@id"/> - the state child element of an modprobe_test must reference an modprobe_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="modprobe_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>
                    The modprobe_object element is used by a modprobe test to define the object to be evaluated. Each object extends the standard ObjectType as defined in 
                    the oval-definitions-schema and one should refer to the ObjectType description for more information. The common set element allows complex objects to 
                    be created using filters and set logic. Again, please refer to the description of the set element in the oval-definitions-schema.
               </xsd:documentation>
               <xsd:documentation>
                    Collection of a modprobe_object is determined by the "modprobe -n -v module_name" command.  Due to the limitations of the modprobe command, and its
                    requirement for a specific module_name, only the "equals" operation is supported, as there is no method to collect this information otherwise.  To support 
                    other collection methods, variable references should be used to collect specific module names for use in collection here.
               </xsd:documentation>
               <xsd:documentation>A modprobe object consists of a single name entity that identifies the package being checked.</xsd:documentation>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_modprobe_object_verify_filter_state">
                         <sch:rule context="linux-def:modprobe_object//oval-def:filter">
                              <sch:let name="parent_object" value="ancestor::linux-def:modprobe_object"/>
                              <sch:let name="parent_object_id" value="$parent_object/@id"/>
                              <sch:let name="state_ref" value="."/>
                              <sch:let name="reffed_state" value="ancestor::oval-def:oval_definitions/oval-def:states/*[@id=$state_ref]"/>
                              <sch:let name="state_name" value="local-name($reffed_state)"/>
                              <sch:let name="state_namespace" value="namespace-uri($reffed_state)"/>
                              <sch:assert test="(($state_namespace='http://oval.mitre.org/XMLSchema/oval-definitions-5#linux') and ($state_name='modprobe_state'))">State referenced in filter for <sch:value-of select="name($parent_object)"/> '<sch:value-of select="$parent_object_id"/>' is of the wrong type. </sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="module_name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the name of the kernel module to check.  Due to the nature of this test, only the "equals" operation is supported, as there is no method to collect this information otherwise.</xsd:documentation>
                                                  <xsd:appinfo>
                                                       <sch:pattern id="linux-def_modprobeobjmodulename">
                                                            <sch:rule context="linux-def:modprobe_object/linux-def:module_name">
                                                                 <sch:assert test="not(@operation) or @operation='equals'"><sch:value-of select="../@id"/> - operation attribute for the module_name entity of a modprobe_object should be 'equals', note that this overrules the general operation attribute validation (i.e. follow this one)</sch:assert>
                                                            </sch:rule>
                                                       </sch:pattern>
                                                  </xsd:appinfo>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="modprobe_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>The modprobe_state element defines the different information that can be used to evaluate the specified kernel module. Please refer to the individual elements in the schema for more details about what each represents.</xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="module_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The name of the kernel module for which information was collected</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="modprobe_line" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The modprobe_line element represents a single line of output from the "modprobe -n -v [module_name]" command.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <!-- =============================================================================== -->
     <!-- ============================  KERNEL MODULE TEST  ============================= -->
     <!-- =============================================================================== -->
     <xsd:element name="kernelmodule_test" substitutionGroup="oval-def:test">
          <xsd:annotation>
               <xsd:documentation>
                    The kernelmodule_test is used to check the loaded/loadability status for a given kernel module. It extends the standard TestType as defined in the oval-definitions-schema 
                    and one should refer to the TestType description for more information. The required object element references a kernelmodule_object and the optional state 
                    element specifies the data to check.
               </xsd:documentation>
               <xsd:appinfo>
                    <oval:element_mapping>
                         <oval:test>kernelmodule_test</oval:test>
                         <oval:object>kernelmodule_object</oval:object>
                         <oval:state>kernelmodule_state</oval:state>
                         <oval:item target_namespace="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5#linux">kernelmodule_item</oval:item>
                    </oval:element_mapping>
               </xsd:appinfo>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_kernelmodule_test">
                         <sch:rule context="linux-def:kernelmodule_test/linux-def:object">
                              <sch:assert test="@object_ref=ancestor::oval-def:oval_definitions/oval-def:objects/linux-def:kernelmodule_object/@id"><sch:value-of select="../@id"/> - the object child element of a kernelmodule_test must reference a kernelmodule_object</sch:assert>
                         </sch:rule>
                         <sch:rule context="linux-def:kernelmodule_test/linux-def:state">
                              <sch:assert test="@state_ref=ancestor::oval-def:oval_definitions/oval-def:states/linux-def:kernelmodule_state/@id"><sch:value-of select="../@id"/> - the state child element of a kernelmodule_test must reference a kernelmodule_state</sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:TestType">
                         <xsd:sequence>
                              <xsd:element name="object" type="oval-def:ObjectRefType" />
                              <xsd:element name="state" type="oval-def:StateRefType" minOccurs="0" maxOccurs="unbounded"/>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="kernelmodule_object" substitutionGroup="oval-def:object">
          <xsd:annotation>
               <xsd:documentation>
                    The kernelmodule_object element is used by the kernelmodule_test to specify those modules for which information will be collected.  This object, 
                    using the specified module_name, will collect information on the current loaded and loadable status of the module.
               </xsd:documentation>
               <xsd:documentation>
                    By default modprobe loads modules from subdirectories located in the /lib/modules/$(uname -r) directory. Usually the files have an extension of .ko, 
                    so they can be listed like this:  find /lib/modules/$(uname -r) -type f -name '*.ko*'.  An example line of output from this command would look like:
                    /lib/modules/3.10.0-693.21.1.el7.x86_64/kernel/sound/usb/line6/snd-usb-pod.ko.xz.  In this case, the module name would be "snd-usb-pod".  This 
                    information may be useful when needing to collect kernel module information based on operators other than "equals", such as pattern matching.
               </xsd:documentation>
               <xsd:documentation>
                    To populate the "loaded" element for a kernelmodule_item, the specified module name must appear in the output of the "lsmod" command.  "lsmod" is a 
                    trivial program which nicely formats the contents of the /proc/modules, showing what kernel modules are currently loaded.
               </xsd:documentation>
               <xsd:documentation>
                    To populate the "loadable" element for a kernelmodule_item, implementors should explore the output of the "modprobe -n -v [module_name]" command.  If 
                    the output of this command contains a line reading "install /bin/true" then the module is NOT loadable.  Another option is to parse the output of the 
                    "modprobe --showconfig" command.  Similarly, if an output line matches "install [module_name] /bin/true", then the module is NOT loadable.
               </xsd:documentation>
               <xsd:documentation>A kernelmodule_object consists of a single module_name entity that identifies the package being checked.</xsd:documentation>
               <xsd:appinfo>
                    <sch:pattern id="linux-def_kernelmodule_object_verify_filter_state">
                         <sch:rule context="linux-def:kernelmodule_object//oval-def:filter">
                              <sch:let name="parent_object" value="ancestor::linux-def:kernelmodule_object"/>
                              <sch:let name="parent_object_id" value="$parent_object/@id"/>
                              <sch:let name="state_ref" value="."/>
                              <sch:let name="reffed_state" value="ancestor::oval-def:oval_definitions/oval-def:states/*[@id=$state_ref]"/>
                              <sch:let name="state_name" value="local-name($reffed_state)"/>
                              <sch:let name="state_namespace" value="namespace-uri($reffed_state)"/>
                              <sch:assert test="(($state_namespace='http://oval.mitre.org/XMLSchema/oval-definitions-5#linux') and ($state_name='kernelmodule_state'))">State referenced in filter for <sch:value-of select="name($parent_object)"/> '<sch:value-of select="$parent_object_id"/>' is of the wrong type. </sch:assert>
                         </sch:rule>
                    </sch:pattern>
               </xsd:appinfo>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:ObjectType">
                         <xsd:sequence>
                              <xsd:choice>
                                   <xsd:element ref="oval-def:set"/>
                                   <xsd:sequence>
                                        <xsd:element name="module_name" type="oval-def:EntityObjectStringType">
                                             <xsd:annotation>
                                                  <xsd:documentation>This is the name of the kernel module to collect.</xsd:documentation>
                                             </xsd:annotation>
                                        </xsd:element>
                                        <xsd:element ref="oval-def:filter" minOccurs="0" maxOccurs="unbounded"/>
                                   </xsd:sequence>
                              </xsd:choice>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
     <xsd:element name="kernelmodule_state" substitutionGroup="oval-def:state">
          <xsd:annotation>
               <xsd:documentation>
                    The kernelmodule_state element defines the different information that can be used to evaluate the specified 
                    kernel module. Please refer to the individual elements in the schema for more details about what each represents.
               </xsd:documentation>
          </xsd:annotation>
          <xsd:complexType>
               <xsd:complexContent>
                    <xsd:extension base="oval-def:StateType">
                         <xsd:sequence>
                              <xsd:element name="module_name" type="oval-def:EntityStateStringType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The name of the kernel module for which information was collected</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="loaded" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The loaded element is true when the collected kernel module is currently loaded; false otherwise.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                              <xsd:element name="loadable" type="oval-def:EntityStateBoolType" minOccurs="0" maxOccurs="1">
                                   <xsd:annotation>
                                        <xsd:documentation>The loadable element is true when the collected kernel module is allowed to be loaded; false otherwise.</xsd:documentation>
                                   </xsd:annotation>
                              </xsd:element>
                         </xsd:sequence>
                    </xsd:extension>
               </xsd:complexContent>
          </xsd:complexType>
     </xsd:element>
</xsd:schema>
